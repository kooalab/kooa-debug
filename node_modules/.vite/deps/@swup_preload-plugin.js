import {
  e
} from "./chunk-MVBKK32R.js";
import {
  l,
  n
} from "./chunk-MFRXIDBF.js";
import "./chunk-Y2F7D3TJ.js";

// node_modules/@swup/preload-plugin/dist/index.modern.js
function o() {
  return o = Object.assign ? Object.assign.bind() : function(e2) {
    for (var t = 1; t < arguments.length; t++) {
      var s = arguments[t];
      for (var o2 in s)
        Object.prototype.hasOwnProperty.call(s, o2) && (e2[o2] = s[o2]);
    }
    return e2;
  }, o.apply(this, arguments);
}
function r() {
  return window.matchMedia("(hover: hover)").matches;
}
var i = window.requestIdleCallback || ((e2) => setTimeout(e2, 1));
var n2 = ["preloadVisibleLinks"];
var a = class extends e {
  constructor(e2 = {}) {
    var t;
    super(), t = this, this.name = "SwupPreloadPlugin", this.requires = { swup: ">=4" }, this.defaults = { throttle: 5, preloadInitialPage: true, preloadHoveredLinks: true, preloadVisibleLinks: { enabled: false, threshold: 0.2, delay: 500, containers: ["body"], ignore: () => false } }, this.options = void 0, this.queue = void 0, this.preloadObserver = void 0, this.preloadPromises = /* @__PURE__ */ new Map(), this.mouseEnterDelegate = void 0, this.touchStartDelegate = void 0, this.focusDelegate = void 0, this.onPageLoad = (e3, t2, s2) => {
      const { url: o2 } = e3.to;
      return o2 && this.preloadPromises.has(o2) ? this.preloadPromises.get(o2) : s2(e3, t2);
    }, this.onMouseEnter = async function(e3) {
      if (e3.target !== e3.delegateTarget)
        return;
      if (!r())
        return;
      const s2 = e3.delegateTarget;
      s2 instanceof HTMLAnchorElement && (t.swup.hooks.callSync("link:hover", { el: s2, event: e3 }), t.preload(s2, { priority: true }));
    }, this.onTouchStart = (e3) => {
      if (r())
        return;
      const t2 = e3.delegateTarget;
      t2 instanceof HTMLAnchorElement && this.preload(t2, { priority: true });
    }, this.onFocus = (e3) => {
      const t2 = e3.delegateTarget;
      t2 instanceof HTMLAnchorElement && this.preload(t2, { priority: true });
    };
    const { preloadVisibleLinks: s } = e2, i2 = function(e3, t2) {
      if (null == e3)
        return {};
      var s2, o2, r2 = {}, i3 = Object.keys(e3);
      for (o2 = 0; o2 < i3.length; o2++)
        t2.indexOf(s2 = i3[o2]) >= 0 || (r2[s2] = e3[s2]);
      return r2;
    }(e2, n2);
    this.options = o({}, this.defaults, i2), "object" == typeof s ? this.options.preloadVisibleLinks = o({}, this.options.preloadVisibleLinks, { enabled: true }, s) : this.options.preloadVisibleLinks.enabled = Boolean(s), this.preload = this.preload.bind(this), this.queue = /* @__PURE__ */ function(e3 = 1) {
      const t2 = [], s2 = [];
      let o2 = 0, r2 = 0;
      function i3() {
        r2 < e3 && o2 > 0 && ((s2.shift() || t2.shift() || (() => {
        }))(), o2--, r2++);
      }
      return { add: function(e4, r3 = false) {
        if (e4.__queued) {
          if (!r3)
            return;
          {
            const s3 = t2.indexOf(e4);
            if (s3 >= 0) {
              const e5 = t2.splice(s3, 1);
              o2 -= e5.length;
            }
          }
        }
        e4.__queued = true, (r3 ? s2 : t2).push(e4), o2++, o2 <= 1 && i3();
      }, next: function() {
        r2--, i3();
      } };
    }(this.options.throttle);
  }
  mount() {
    const e2 = this.swup;
    e2.options.cache ? (e2.hooks.create("page:preload"), e2.hooks.create("link:hover"), e2.preload = this.preload, e2.preloadLinks = this.preloadLinks, this.replace("page:load", this.onPageLoad), this.preloadLinks(), this.on("page:view", () => this.preloadLinks()), this.options.preloadVisibleLinks.enabled && (this.preloadVisibleLinks(), this.on("page:view", () => this.preloadVisibleLinks())), this.options.preloadHoveredLinks && this.preloadLinksOnAttention(), this.options.preloadInitialPage && this.preload(n())) : console.warn("SwupPreloadPlugin: swup cache needs to be enabled for preloading");
  }
  unmount() {
    var e2, t, s;
    this.swup.preload = void 0, this.swup.preloadLinks = void 0, this.preloadPromises.clear(), null == (e2 = this.mouseEnterDelegate) || e2.destroy(), null == (t = this.touchStartDelegate) || t.destroy(), null == (s = this.focusDelegate) || s.destroy(), this.stopPreloadingVisibleLinks();
  }
  async preload(e2, t = {}) {
    var o2;
    let r2, i2;
    const n3 = null != (o2 = t.priority) && o2;
    if (Array.isArray(e2))
      return Promise.all(e2.map((e3) => this.preload(e3)));
    if (e2 instanceof HTMLAnchorElement)
      i2 = e2, { url: r2 } = l.fromElement(e2);
    else {
      if ("string" != typeof e2)
        return;
      r2 = e2;
    }
    if (this.preloadPromises.has(r2))
      return this.preloadPromises.get(r2);
    if (!this.shouldPreload(r2, { el: i2 }))
      return;
    const a2 = new Promise((e3) => {
      this.queue.add(() => {
        this.performPreload(r2).catch(() => {
        }).then((t2) => e3(t2)).finally(() => {
          this.queue.next(), this.preloadPromises.delete(r2);
        });
      }, n3);
    });
    return this.preloadPromises.set(r2, a2), a2;
  }
  preloadLinks() {
    i(() => {
      Array.from(document.querySelectorAll("a[data-swup-preload], [data-swup-preload-all] a")).forEach((e2) => this.preload(e2));
    });
  }
  preloadLinksOnAttention() {
    const { swup: e2 } = this, { linkSelector: t } = e2.options, s = { passive: true, capture: true };
    this.mouseEnterDelegate = e2.delegateEvent(t, "mouseenter", this.onMouseEnter, s), this.touchStartDelegate = e2.delegateEvent(t, "touchstart", this.onTouchStart, s), this.focusDelegate = e2.delegateEvent(t, "focus", this.onFocus, s);
  }
  preloadVisibleLinks() {
    if (this.preloadObserver)
      return void this.preloadObserver.update();
    const { threshold: e2, delay: t, containers: s } = this.options.preloadVisibleLinks;
    this.preloadObserver = function({ threshold: e3, delay: t2, containers: s2, callback: o2, filter: r2 }) {
      const n3 = /* @__PURE__ */ new Map(), a2 = new IntersectionObserver((e4) => {
        e4.forEach((e5) => {
          e5.isIntersecting ? l2(e5.target) : h(e5.target);
        });
      }, { threshold: e3 }), l2 = (e4) => {
        var s3;
        const r3 = null != (s3 = n3.get(e4.href)) ? s3 : /* @__PURE__ */ new Set();
        n3.set(e4.href, r3), r3.add(e4), setTimeout(() => {
          const t3 = n3.get(e4.href);
          null != t3 && t3.size && (o2(e4), a2.unobserve(e4), t3.delete(e4));
        }, t2);
      }, h = (e4) => {
        var t3;
        return null == (t3 = n3.get(e4.href)) ? void 0 : t3.delete(e4);
      }, d = () => {
        i(() => {
          const e4 = s2.map((e5) => `${e5} a[href]`).join(", ");
          Array.from(document.querySelectorAll(e4)).filter((e5) => r2(e5)).forEach((e5) => a2.observe(e5));
        });
      };
      return { start: () => d(), stop: () => a2.disconnect(), update: () => (n3.clear(), d()) };
    }({ threshold: e2, delay: t, containers: s, callback: (e3) => this.preload(e3), filter: (e3) => !this.options.preloadVisibleLinks.ignore(e3) && this.shouldPreload(e3.href, { el: e3 }) }), this.preloadObserver.start();
  }
  stopPreloadingVisibleLinks() {
    this.preloadObserver && this.preloadObserver.stop();
  }
  shouldPreload(e2, { el: o2 } = {}) {
    const { url: r2, href: i2 } = l.fromUrl(e2);
    return !(!function() {
      if (navigator.connection) {
        var e3;
        if (navigator.connection.saveData)
          return false;
        if (null != (e3 = navigator.connection.effectiveType) && e3.endsWith("2g"))
          return false;
      }
      return true;
    }() || this.swup.cache.has(r2) || this.preloadPromises.has(r2) || this.swup.shouldIgnoreVisit(i2, { el: o2 }) || o2 && this.swup.resolveUrl(r2) === this.swup.resolveUrl(n()));
  }
  async performPreload(e2) {
    const t = await this.swup.fetchPage(e2);
    return await this.swup.hooks.call("page:preload", { page: t }), t;
  }
};
export {
  a as default
};
//# sourceMappingURL=@swup_preload-plugin.js.map
