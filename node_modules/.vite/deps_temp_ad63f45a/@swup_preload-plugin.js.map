{
  "version": 3,
  "sources": ["../../@swup/preload-plugin/src/util.ts", "../../@swup/preload-plugin/src/index.ts", "../../@swup/preload-plugin/src/queue.ts", "../../@swup/preload-plugin/src/observer.ts"],
  "sourcesContent": ["/**\n * Check if the user's connection is configured and fast enough\n * to preload data in the background.\n */\nexport function networkSupportsPreloading(): boolean {\n\tif (navigator.connection) {\n\t\tif (navigator.connection.saveData) {\n\t\t\treturn false;\n\t\t}\n\t\tif (navigator.connection.effectiveType?.endsWith('2g')) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * Does this device support true hover/pointer interactions?\n */\nexport function deviceSupportsHover() {\n\treturn window.matchMedia('(hover: hover)').matches;\n}\n\n/**\n * Safe requestIdleCallback function that falls back to setTimeout\n */\nexport const whenIdle = window.requestIdleCallback || ((cb) => setTimeout(cb, 1));\n", "import Plugin from '@swup/plugin';\nimport { getCurrentUrl, Location } from 'swup';\nimport type {\n\tDelegateEvent,\n\tDelegateEventHandler,\n\tDelegateEventUnsubscribe,\n\tPageData,\n\tHookDefaultHandler\n} from 'swup';\nimport { deviceSupportsHover, networkSupportsPreloading, whenIdle } from './util.js';\nimport createQueue, { Queue } from './queue.js';\nimport createObserver, { Observer } from './observer.js';\n\ndeclare module 'swup' {\n\texport interface Swup {\n\t\t/**\n\t\t * Preload links by passing in either:\n\t\t * - a URL or an array of URLs\n\t\t * - a link element or an array of link elements\n\t\t */\n\t\tpreload?: SwupPreloadPlugin['preload'];\n\t\t/**\n\t\t * Preload any links on the current page manually marked for preloading.\n\t\t */\n\t\tpreloadLinks?: () => void;\n\t}\n\texport interface HookDefinitions {\n\t\t'link:hover': { el: HTMLAnchorElement; event: DelegateEvent };\n\t\t'page:preload': { page: PageData };\n\t}\n}\n\ntype VisibleLinkPreloadOptions = {\n\t/** Enable preloading of links entering the viewport */\n\tenabled: boolean;\n\t/** How much area of a link must be visible to preload it: 0 to 1.0 */\n\tthreshold: number;\n\t/** How long a link must be visible to preload it, in milliseconds */\n\tdelay: number;\n\t/** Containers to look for links in */\n\tcontainers: string[];\n\t/** Callback for opting out selected elements from preloading */\n\tignore: (el: HTMLAnchorElement) => boolean;\n};\n\nexport type PluginOptions = {\n\t/** The *concurrency limit* for simultaneous requests when preloading. */\n\tthrottle: number;\n\t/** Preload the initial page to allow instant back-button navigation. */\n\tpreloadInitialPage: boolean;\n\t/** Preload links when they are hovered, touched or focused. */\n\tpreloadHoveredLinks: boolean;\n\t/** Preload links when they enter the viewport. */\n\tpreloadVisibleLinks: VisibleLinkPreloadOptions;\n};\n\nexport type PluginInitOptions = Omit<PluginOptions, 'preloadVisibleLinks'> & {\n\t/** Preload links when they enter the viewport. */\n\tpreloadVisibleLinks: boolean | Partial<VisibleLinkPreloadOptions>;\n};\n\ntype PreloadOptions = {\n\t/** Priority of this preload: `true` for high, `false` for low. */\n\tpriority?: boolean;\n};\n\nexport default class SwupPreloadPlugin extends Plugin {\n\tname = 'SwupPreloadPlugin';\n\n\trequires = { swup: '>=4' };\n\n\tdefaults: PluginOptions = {\n\t\tthrottle: 5,\n\t\tpreloadInitialPage: true,\n\t\tpreloadHoveredLinks: true,\n\t\tpreloadVisibleLinks: {\n\t\t\tenabled: false,\n\t\t\tthreshold: 0.2,\n\t\t\tdelay: 500,\n\t\t\tcontainers: ['body'],\n\t\t\tignore: () => false\n\t\t}\n\t};\n\n\toptions: PluginOptions;\n\n\tprotected queue: Queue;\n\tprotected preloadObserver?: Observer;\n\tprotected preloadPromises = new Map<string, Promise<PageData | void>>();\n\n\tprotected mouseEnterDelegate?: DelegateEventUnsubscribe;\n\tprotected touchStartDelegate?: DelegateEventUnsubscribe;\n\tprotected focusDelegate?: DelegateEventUnsubscribe;\n\n\tconstructor(options: Partial<PluginInitOptions> = {}) {\n\t\tsuper();\n\n\t\t// Set all options except `preloadVisibleLinks` which is sanitized below\n\t\tconst { preloadVisibleLinks, ...otherOptions } = options;\n\t\tthis.options = { ...this.defaults, ...otherOptions };\n\n\t\t// Sanitize/merge `preloadVisibleLinks`` option\n\t\tif (typeof preloadVisibleLinks === 'object') {\n\t\t\tthis.options.preloadVisibleLinks = {\n\t\t\t\t...this.options.preloadVisibleLinks,\n\t\t\t\tenabled: true,\n\t\t\t\t...preloadVisibleLinks\n\t\t\t};\n\t\t} else {\n\t\t\tthis.options.preloadVisibleLinks.enabled = Boolean(preloadVisibleLinks);\n\t\t}\n\n\t\t// Bind public methods\n\t\tthis.preload = this.preload.bind(this);\n\n\t\t// Create global priority queue\n\t\tthis.queue = createQueue(this.options.throttle);\n\t}\n\n\tmount() {\n\t\tconst swup = this.swup;\n\n\t\tif (!swup.options.cache) {\n\t\t\tconsole.warn('SwupPreloadPlugin: swup cache needs to be enabled for preloading');\n\t\t\treturn;\n\t\t}\n\n\t\tswup.hooks.create('page:preload');\n\t\tswup.hooks.create('link:hover');\n\n\t\t// @ts-ignore: non-matching signatures (TODO: fix properly)\n\t\tswup.preload = this.preload;\n\t\tswup.preloadLinks = this.preloadLinks;\n\n\t\t// Inject custom promise whenever a page is loaded\n\t\tthis.replace('page:load', this.onPageLoad);\n\n\t\t// Preload links with [data-swup-preload] attr\n\t\tthis.preloadLinks();\n\t\tthis.on('page:view', () => this.preloadLinks());\n\n\t\t// Preload visible links in viewport\n\t\tif (this.options.preloadVisibleLinks.enabled) {\n\t\t\tthis.preloadVisibleLinks();\n\t\t\tthis.on('page:view', () => this.preloadVisibleLinks());\n\t\t}\n\n\t\t// Preload links on attention\n\t\tif (this.options.preloadHoveredLinks) {\n\t\t\tthis.preloadLinksOnAttention();\n\t\t}\n\n\t\t// Cache unmodified DOM of initial/current page\n\t\tif (this.options.preloadInitialPage) {\n\t\t\tthis.preload(getCurrentUrl());\n\t\t}\n\t}\n\n\tunmount() {\n\t\tthis.swup.preload = undefined;\n\t\tthis.swup.preloadLinks = undefined;\n\n\t\tthis.preloadPromises.clear();\n\n\t\tthis.mouseEnterDelegate?.destroy();\n\t\tthis.touchStartDelegate?.destroy();\n\t\tthis.focusDelegate?.destroy();\n\n\t\tthis.stopPreloadingVisibleLinks();\n\t}\n\n\t/**\n\t * Before core page load: return existing preload promise if available.\n\t */\n\tprotected onPageLoad: HookDefaultHandler<'page:load'> = (visit, args, defaultHandler) => {\n\t\tconst { url } = visit.to;\n\t\tif (url && this.preloadPromises.has(url)) {\n\t\t\treturn this.preloadPromises.get(url) as Promise<PageData>;\n\t\t}\n\t\treturn defaultHandler!(visit, args);\n\t};\n\n\t/**\n\t * When hovering over a link: preload the linked page with high priority.\n\t */\n\tprotected onMouseEnter: DelegateEventHandler = async (event) => {\n\t\t// Make sure mouseenter is only fired once even on links with nested html\n\t\tif (event.target !== event.delegateTarget) return;\n\n\t\t// Return early on devices that don't support hover\n\t\tif (!deviceSupportsHover()) return;\n\n\t\tconst el = event.delegateTarget;\n\t\tif (!(el instanceof HTMLAnchorElement)) return;\n\n\t\tthis.swup.hooks.callSync('link:hover', { el, event });\n\t\tthis.preload(el, { priority: true });\n\t};\n\n\t/**\n\t * When touching a link: preload the linked page with high priority.\n\t */\n\tprotected onTouchStart: DelegateEventHandler = (event) => {\n\t\t// Return early on devices that support hover\n\t\tif (deviceSupportsHover()) return;\n\n\t\tconst el = event.delegateTarget;\n\t\tif (!(el instanceof HTMLAnchorElement)) return;\n\n\t\tthis.preload(el, { priority: true });\n\t};\n\n\t/**\n\t * When focussing a link: preload the linked page with high priority.\n\t */\n\tprotected onFocus: DelegateEventHandler = (event) => {\n\t\tconst el = event.delegateTarget;\n\t\tif (!(el instanceof HTMLAnchorElement)) return;\n\n\t\tthis.preload(el, { priority: true });\n\t};\n\n\t/**\n\t * Preload links.\n\t *\n\t * The method accepts either:\n\t * - a URL or an array of URLs\n\t * - a link element or an array of link elements\n\t *\n\t * It returns either:\n\t * - a Promise resolving to the page data, if requesting a single page\n\t * - a Promise resolving to an array of page data, if requesting multiple pages\n\t */\n\tasync preload(url: string, options?: PreloadOptions): Promise<PageData | void>;\n\tasync preload(urls: string[], options?: PreloadOptions): Promise<(PageData | void)[]>;\n\tasync preload(el: HTMLAnchorElement, options?: PreloadOptions): Promise<PageData | void>;\n\tasync preload(els: HTMLAnchorElement[], options?: PreloadOptions): Promise<(PageData | void)[]>;\n\tasync preload(\n\t\tinput: string | HTMLAnchorElement,\n\t\toptions?: PreloadOptions\n\t): Promise<PageData | void>;\n\tasync preload(\n\t\tinput: string | string[] | HTMLAnchorElement | HTMLAnchorElement[],\n\t\toptions: PreloadOptions = {}\n\t): Promise<PageData | (PageData | void)[] | void> {\n\t\tlet url: string;\n\t\tlet el: HTMLAnchorElement | undefined;\n\t\tconst priority = options.priority ?? false;\n\n\t\t// Allow passing in array of urls or elements\n\t\tif (Array.isArray(input)) {\n\t\t\treturn Promise.all(input.map((link) => this.preload(link)));\n\t\t}\n\t\t// Allow passing in an anchor element\n\t\telse if (input instanceof HTMLAnchorElement) {\n\t\t\tel = input;\n\t\t\t({ url } = Location.fromElement(input));\n\t\t}\n\t\t// Allow passing in a url\n\t\telse if (typeof input === 'string') {\n\t\t\turl = input;\n\t\t}\n\t\t// Disallow other types\n\t\telse {\n\t\t\treturn;\n\t\t}\n\n\t\t// Already preloading? Return existing promise\n\t\tif (this.preloadPromises.has(url)) {\n\t\t\treturn this.preloadPromises.get(url);\n\t\t}\n\n\t\t// Should we preload?\n\t\tif (!this.shouldPreload(url, { el })) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Queue the preload with either low or high priority\n\t\t// The actual preload will happen when a spot in the queue is available\n\t\tconst queuedPromise = new Promise<PageData | void>((resolve) => {\n\t\t\tthis.queue.add(() => {\n\t\t\t\tthis.performPreload(url)\n\t\t\t\t\t.catch(() => {})\n\t\t\t\t\t.then((page) => resolve(page))\n\t\t\t\t\t.finally(() => {\n\t\t\t\t\t\tthis.queue.next();\n\t\t\t\t\t\tthis.preloadPromises.delete(url);\n\t\t\t\t\t});\n\t\t\t}, priority);\n\t\t});\n\n\t\tthis.preloadPromises.set(url, queuedPromise);\n\n\t\treturn queuedPromise;\n\t}\n\n\t/**\n\t * Preload any links on the current page manually marked for preloading.\n\t *\n\t * Links are marked for preloading by:\n\t * - adding a `data-swup-preload` attribute to the link itself\n\t * - adding a `data-swup-preload-all` attribute to a container of multiple links\n\t */\n\tpreloadLinks(): void {\n\t\twhenIdle(() => {\n\t\t\tconst selector = 'a[data-swup-preload], [data-swup-preload-all] a';\n\t\t\tconst links = Array.from(document.querySelectorAll<HTMLAnchorElement>(selector));\n\t\t\tlinks.forEach((el) => this.preload(el));\n\t\t});\n\t}\n\n\t/**\n\t * Register handlers for preloading on attention:\n\t *  - mouseenter\n\t *  - touchstart\n\t *  - focus\n\t */\n\tprotected preloadLinksOnAttention() {\n\t\tconst { swup } = this;\n\n\t\tconst { linkSelector: selector } = swup.options;\n\t\tconst opts = { passive: true, capture: true };\n\t\tthis.mouseEnterDelegate = swup.delegateEvent(\n\t\t\tselector,\n\t\t\t'mouseenter',\n\t\t\tthis.onMouseEnter,\n\t\t\topts\n\t\t);\n\t\tthis.touchStartDelegate = swup.delegateEvent(\n\t\t\tselector,\n\t\t\t'touchstart',\n\t\t\tthis.onTouchStart,\n\t\t\topts\n\t\t);\n\t\tthis.focusDelegate = swup.delegateEvent(selector, 'focus', this.onFocus, opts);\n\t}\n\n\t/**\n\t * Start observing links in the viewport for preloading.\n\t * Calling this repeatedly re-checks for links after DOM updates.\n\t */\n\tprotected preloadVisibleLinks(): void {\n\t\t// Scan DOM for new links on repeated calls\n\t\tif (this.preloadObserver) {\n\t\t\tthis.preloadObserver.update();\n\t\t\treturn;\n\t\t}\n\n\t\tconst { threshold, delay, containers } = this.options.preloadVisibleLinks;\n\t\tconst callback = (el: HTMLAnchorElement) => this.preload(el);\n\t\tconst filter = (el: HTMLAnchorElement) => {\n\t\t\t/** First, run the custom callback */\n\t\t\tif (this.options.preloadVisibleLinks.ignore(el)) return false;\n\t\t\t/** Second, run all default checks */\n\t\t\treturn this.shouldPreload(el.href, { el });\n\t\t};\n\t\tthis.preloadObserver = createObserver({ threshold, delay, containers, callback, filter });\n\t\tthis.preloadObserver.start();\n\t}\n\n\t/**\n\t * Stop observing links in the viewport for preloading.\n\t */\n\tprotected stopPreloadingVisibleLinks(): void {\n\t\tif (this.preloadObserver) {\n\t\t\tthis.preloadObserver.stop();\n\t\t}\n\t}\n\n\t/**\n\t * Check whether a URL and/or element should trigger a preload.\n\t */\n\tprotected shouldPreload(location: string, { el }: { el?: HTMLAnchorElement } = {}): boolean {\n\t\tconst { url, href } = Location.fromUrl(location);\n\n\t\t// Network too slow?\n\t\tif (!networkSupportsPreloading()) return false;\n\t\t// Already in cache?\n\t\tif (this.swup.cache.has(url)) return false;\n\t\t// Already preloading?\n\t\tif (this.preloadPromises.has(url)) return false;\n\t\t// Should be ignored anyway?\n\t\tif (this.swup.shouldIgnoreVisit(href, { el })) return false;\n\t\t// Special condition for links: points to current page?\n\t\tif (el && this.swup.resolveUrl(url) === this.swup.resolveUrl(getCurrentUrl())) return false;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Perform the actual preload fetch and trigger the preload hook.\n\t */\n\tprotected async performPreload(url: string): Promise<PageData> {\n\t\tconst page = await this.swup.fetchPage(url);\n\t\tawait this.swup.hooks.call('page:preload', { page });\n\t\treturn page;\n\t}\n}\n", "type QueueFunction = {\n\t(): void;\n\t__queued?: boolean;\n};\n\nexport type Queue = {\n\tadd: (fn: QueueFunction, highPriority?: boolean) => void;\n\tnext: () => void;\n};\n\nexport default function createQueue(limit: number = 1): Queue {\n\tconst qlow: QueueFunction[] = [];\n\tconst qhigh: QueueFunction[] = [];\n\tlet total = 0;\n\tlet running = 0;\n\n\tfunction add(fn: QueueFunction, highPriority: boolean = false): void {\n\t\t// Already added before?\n\t\tif (fn.__queued) {\n\t\t\t// Move from low to high-priority queue\n\t\t\tif (highPriority) {\n\t\t\t\tconst idx = qlow.indexOf(fn);\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tconst removed = qlow.splice(idx, 1);\n\t\t\t\t\ttotal = total - removed.length;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Mark as processed\n\t\tfn.__queued = true;\n\t\t// Push to queue: high or low\n\t\t(highPriority ? qhigh : qlow).push(fn);\n\t\t// Increment total\n\t\ttotal++;\n\t\t// Initialize queue if first item\n\t\tif (total <= 1) {\n\t\t\trun();\n\t\t}\n\t}\n\n\tfunction next(): void {\n\t\trunning--; // make room for next\n\t\trun();\n\t}\n\n\tfunction run(): void {\n\t\tif (running < limit && total > 0) {\n\t\t\tconst fn = qhigh.shift() || qlow.shift() || (() => {});\n\t\t\tfn();\n\t\t\ttotal--;\n\t\t\trunning++; // is now WIP\n\t\t}\n\t}\n\n\treturn { add, next };\n}\n", "import { whenIdle } from './util.js';\n\nexport type Observer = {\n\tstart: () => void;\n\tstop: () => void;\n\tupdate: () => void;\n};\n\nexport default function createObserver({\n\tthreshold,\n\tdelay,\n\tcontainers,\n\tcallback,\n\tfilter\n}: {\n\tthreshold: number;\n\tdelay: number;\n\tcontainers: string[];\n\tcallback: (el: HTMLAnchorElement) => void;\n\tfilter: (el: HTMLAnchorElement) => boolean;\n}): Observer {\n\tconst visibleLinks = new Map<string, Set<HTMLAnchorElement>>();\n\n\t// Create an observer to add/remove links when they enter the viewport\n\tconst observer = new IntersectionObserver(\n\t\t(entries) => {\n\t\t\tentries.forEach((entry) => {\n\t\t\t\tif (entry.isIntersecting) {\n\t\t\t\t\tadd(entry.target as HTMLAnchorElement);\n\t\t\t\t} else {\n\t\t\t\t\tremove(entry.target as HTMLAnchorElement);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\t{ threshold }\n\t);\n\n\t// Preload link if it is still visible after a configurable timeout\n\tconst add = (el: HTMLAnchorElement) => {\n\t\tconst elements = visibleLinks.get(el.href) ?? new Set();\n\t\tvisibleLinks.set(el.href, elements);\n\t\telements.add(el);\n\n\t\tsetTimeout(() => {\n\t\t\tconst elements = visibleLinks.get(el.href);\n\t\t\tif (elements?.size) {\n\t\t\t\tcallback(el);\n\t\t\t\tobserver.unobserve(el);\n\t\t\t\telements.delete(el);\n\t\t\t}\n\t\t}, delay);\n\t};\n\n\t// Remove link from list of visible links\n\tconst remove = (el: HTMLAnchorElement) => visibleLinks.get(el.href)?.delete(el);\n\n\t// Clear list of visible links\n\tconst clear = () => visibleLinks.clear();\n\n\t// Scan DOM for preloadable links and start observing their visibility\n\tconst observe = () => {\n\t\twhenIdle(() => {\n\t\t\tconst selector = containers.map((root) => `${root} a[href]`).join(', ');\n\t\t\tconst links = Array.from(document.querySelectorAll<HTMLAnchorElement>(selector));\n\t\t\tlinks.filter((el) => filter(el)).forEach((el) => observer.observe(el));\n\t\t});\n\t};\n\n\treturn {\n\t\tstart: () => observe(),\n\t\tstop: () => observer.disconnect(),\n\t\tupdate: () => (clear(), observe())\n\t};\n}\n"],
  "mappings": "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",
  "names": ["deviceSupportsHover", "window", "matchMedia", "matches", "whenIdle", "requestIdleCallback", "cb", "setTimeout", "_excluded", "SwupPreloadPlugin", "Plugin", "constructor", "options", "_this", "super", "this", "name", "requires", "swup", "defaults", "throttle", "preloadInitialPage", "preloadHoveredLinks", "preloadVisibleLinks", "enabled", "threshold", "delay", "containers", "ignore", "queue", "preloadObserver", "preloadPromises", "Map", "mouseEnterDelegate", "touchStartDelegate", "focusDelegate", "onPageLoad", "visit", "args", "defaultHandler", "url", "to", "has", "get", "onMouseEnter", "async", "event", "target", "delegateTarget", "el", "HTMLAnchorElement", "hooks", "callSync", "preload", "priority", "onTouchStart", "onFocus", "otherOptions", "_extends", "Boolean", "bind", "limit", "qlow", "qhigh", "total", "running", "run", "shift", "add", "fn", "highPriority", "__queued", "idx", "indexOf", "removed", "splice", "length", "push", "next", "mount", "cache", "create", "preloadLinks", "replace", "on", "preloadLinksOnAttention", "getCurrentUrl", "console", "warn", "unmount", "_this$mouseEnterDeleg", "_this$touchStartDeleg", "_this$focusDelegate", "clear", "destroy", "stopPreloadingVisibleLinks", "input", "_options$priority", "Array", "isArray", "Promise", "all", "map", "link", "Location", "fromElement", "shouldPreload", "queuedPromise", "resolve", "performPreload", "catch", "then", "page", "finally", "delete", "set", "from", "document", "querySelectorAll", "forEach", "linkSelector", "selector", "opts", "passive", "capture", "delegateEvent", "update", "callback", "filter", "visibleLinks", "observer", "IntersectionObserver", "entries", "entry", "isIntersecting", "remove", "_visibleLinks$get", "elements", "href", "Set", "size", "unobserve", "_visibleLinks$get2", "observe", "root", "join", "start", "stop", "disconnect", "location", "fromUrl", "navigator", "connection", "_navigator$connection", "saveData", "effectiveType", "endsWith", "networkSupportsPreloading", "shouldIgnoreVisit", "resolveUrl", "fetchPage", "call"]
}
